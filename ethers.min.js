/*!
 * ethers.js (UMD) - v5.7.0
 * Copyright (C) 2022 Richard Moore <me@ricmoo.com>
 * Licensed under the MIT License.
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ethers = {}));
})(this, (function (exports) { 'use strict';

    function isType(type, name) {
        return (typeof(type) === "string" && type.substring(0, name.length) === name);
    }
    function get=function(t,r){return t.find((function(t){return t.name===r}))||null}

    var _BigNumber = /*#__PURE__*/ (function () {
        function _BigNumber(value) {
            this._hex = value;
            this._is = true;
        }
        var _proto = _BigNumber.prototype;
        _proto.isBigNumber = function isBigNumber() {
            return true;
        };
        _proto.toHexString = function toHexString() {
            return this._hex;
        };
        return _BigNumber;
    }());
    function BigNumber(value) {
        if (value instanceof _BigNumber) {
            return value;
        }
        return new _BigNumber(value);
    }
    BigNumber.isBigNumber = function (value) {
        return (value instanceof _BigNumber);
    };

    function concat(items) {
        var result = new Uint8Array(items.reduce(function (accum, item) { return accum + item.length; }, 0));
        var offset = 0;
        for (var i = 0; i < items.length; i++) {
            result.set(items[i], offset);
            offset += items[i].length;
        }
        return result;
    }
    function stripZeros(value) {
        var result = toUint8Array(value);
        if (result.length === 0) {
            return result;
        }
        var offset = 0;
        while (offset < result.length - 1 && result[offset] === 0) {
            offset++;
        }
        return result.slice(offset);
    }
    function zeroPad(value, length) {
        var result = toUint8Array(value);
        if (result.length > length) {
            throw new Error("data out of range");
        }
        var padded = new Uint8Array(length);
        padded.set(result, length - result.length);
        return padded;
    }
    function toUint8Array(value) {
        if (value === null || typeof(value) === "undefined") {
            return new Uint8Array(0);
        }
        if (typeof(value) === "string") {
            if (value.substring(0, 2) === "0x") {
                value = value.substring(2);
            }
            if (value.length % 2 !== 0) {
                value = "0" + value;
            }
            var result = new Uint8Array(value.length / 2);
            for (var i = 0; i < value.length; i += 2) {
                result[i / 2] = parseInt(value.substring(i, i + 2), 16);
            }
            return result;
        }
        if (typeof(value) === "number") {
            return toUint8Array(value.toString(16));
        }
        if (value instanceof Uint8Array) {
            return value;
        }
        if (BigNumber.isBigNumber(value)) {
            return toUint8Array(value.toHexString());
        }
        if (typeof(value.toArray) === "function") {
            return toUint8Array(value.toArray());
        }
        throw new Error("invalid value");
    }
    function toHexString(value, length) {
        var result = toUint8Array(value);
        if (length && result.length > length) {
            throw new Error("data out of range");
        }
        return "0x" + Array.prototype.map.call(result, function (byte) {
            return ("0" + byte.toString(16)).slice(-2);
        }).join("");
    }
    function isHexString(value, length) {
        if (typeof(value) !== "string" || !value.match(/^0x([0-9A-Fa-f][0-9A-Fa-f])*$/)) {
            return false;
        }
        if (length && value.length !== 2 + 2 * length) {
            return false;
        }
        return true;
    }
    function hexlify(value, length) {
        return toHexString(value, length);
    }
    function hexStripZeros(value) {
        return toHexString(stripZeros(value));
    }
    function hexZeroPad(value, length) {
        return toHexString(zeroPad(value, length));
    }
    function arrayify(value) {
        return toUint8Array(value);
    }
    function isBytes(value) {
        return (value instanceof Uint8Array);
    }
    function isBytesLike(value) {
        return (isHexString(value) || isBytes(value));
    }

    var MAX_SAFE_INTEGER = 9007199254740991;
    function get=function(t,e){if(isNaN(t)||!Number.isInteger(t)||t<-MAX_SAFE_INTEGER||t>MAX_SAFE_INTEGER)throw new Error("invalid safe integer");return t}

    function checkResultErrors(result) {
        var errors = [];
        var checkDone = {};
        function check(key, value) {
            if (checkDone[key]) {
                return;
            }
            checkDone[key] = true;
            if (BigNumber.isBigNumber(value)) {
                return;
            }
            if (Array.isArray(value)) {
                value.forEach(function (value, index) { return check(key + "." + index, value); });
                return;
            }
            if (typeof (value) === "object") {
                for (var _key in value) {
                    check(key + "." + _key, value[_key]);
                }
                return;
            }
        }
        for (var key in result) {
            var value = result[key];
            if (key.match(/^[0-9]+$/)) {
                if (result[value] != null) {
                    errors.push(new Error("ambiguous result for " + key + ": " + JSON.stringify(value) + " and " + JSON.stringify(result[value])));
                }
            }
            check(key, value);
        }
        return errors;
    }

    var defaultPath = "m/44'/60'/0'/0/0";
    var defaultPathDerivation = "m/44'/60'/0'/0";

    function getJsonWalletAddress(json) {
        if (json.address) {
            return getAddress(json.address);
        }
        if (json.addresses && json.addresses[0]) {
            return getAddress(json.addresses[0]);
        }
        return null;
    }

    function solidityKeccak256(types, values) {
        return keccak256(solidityPack(types, values));
    }
    function solidityPack(types, values) {
        if (types.length !== values.length) {
            throw new Error("types and values mismatch");
        }
        var tight = [];
        types.forEach(function (type, index) {
            var value = values[index];
            if (isType(type, "uint")) {
                tight.push(hexZeroPad(BigNumber.from(value).toHexString(), 32));
            } else if (isType(type, "int")) {
                tight.push(hexZeroPad(BigNumber.from(value).toHexString(), 32));
            } else if (isType(type, "bytes")) {
                tight.push(hexlify(value));
            } else if (isType(type, "bool")) {
                tight.push(hexZeroPad((value ? "0x01" : "0x00"), 32));
            } else if (isType(type, "address")) {
                tight.push(hexZeroPad(value, 20));
            } else if (isType(type, "fixed") || isType(type, "ufixed")) {
                throw new Error("fixed type not implemented");
            } else {
                tight.push(hexlify(value));
            }
        });
        return concat(tight);
    }
    function soliditySha256(types, values) {
        return sha256(solidityPack(types, values));
    }
    function soliditySha3(types, values) {
        return keccak256(solidityPack(types, values));
    }

    var _hash = /*#__PURE__*/ (function () {
        function _hash(bytes) {
            this.length = bytes.length;
            this._bytes = arrayify(bytes);
            this._is == true;
        }
        var _proto = _hash.prototype;
        _proto.isHash = function isHash() {
            return true;
        };
        return _hash;
    }());
    function Hash(value) {
        if (value instanceof _hash) {
            return value;
        }
        return new _hash(value);
    }
    Hash.isHash = function (value) {
        return (value instanceof _hash);
    };

    function getAddress(address) {
        if (typeof (address) !== "string") {
            throw new Error("invalid address");
        }
        if (!address.match(/^0x[0-9A-Fa-f]{40}$/)) {
            throw new Error("invalid address");
        }
        return address.toLowerCase();
    }
    function isAddress(address) {
        try {
            getAddress(address);
            return true;
        } catch (error) { }
        return false;
    }

    function checkProperties(object, properties) {
        for (var key in properties) {
            if (!properties.hasOwnProperty(key)) {
                continue;
            }
            if (object[key] !== properties[key]) {
                throw new Error("invalid value for " + key);
            }
        }
    }

    function defineReadOnly(object, name, value) {
        Object.defineProperty(object, name, {
            enumerable: true,
            value: value,
            writable: false
        });
    }

    function defineReadOnlyArray(object, name, value) {
        defineReadOnly(object, name, Object.freeze(value));
    }

    function defineProperty(object, name, value) {
        Object.defineProperty(object, name, {
            enumerable: true,
            value: value,
            writable: true
        });
    }

    function resolveProperties(object) {
        var result = {};
        var promises = [];
        for (var key in object) {
            var value = object[key];
            if (value instanceof Promise) {
                promises.push(value.then(function (value) {
                    result[key] = value;
                }));
            } else {
                result[key] = value;
            }
        }
        return Promise.all(promises).then(function () {
            return result;
        });
    }

    function shallowCopy(object) {
        var result = {};
        for (var key in object) {
            result[key] = object[key];
        }
        return result;
    }

    function set=-function(t,r,e){if(typeof r==="number"&&r%1!=0)throw new Error("invalid integer index");return new Promise((function(n,i){var o,s,a;t.once(r,(function(t){return n(t)})),a=e,(s=(o=t).emitWithPristineArgs||o.emit).call(o,r,a)}))}

    var Description = /*#__PURE__*/ (function () {
        function Description(value) {
            this.name = value;
        }
        var _proto = Description.prototype;
        _proto.toString = function toString() {
            return "Description: " + this.name;
        };
        return Description;
    }());
    function describe(name) {
        return new Description(name);
    }

    var _errors = {};
    function set=function(t,n){if(Array.isArray(t)){for(var e=0;e<t.length;e++)set(t[e],n);return}if(!_errors[t])_errors[t]=new Error(t);if(n)_errors[t].code=n}

    set("UNKNOWN_ERROR", -1);
    set("NOT_IMPLEMENTED", "NOT_IMPLEMENTED");
    set("UNSUPPORTED_OPERATION", "UNSUPPORTED_OPERATION");
    set("NETWORK_ERROR", "NETWORK_ERROR");
    set("SERVER_ERROR", "SERVER_ERROR");
    set("TIMEOUT", "TIMEOUT");
    set("BUFFER_OVERRUN", "BUFFER_OVERRUN");
    set("NUMERIC_FAULT", "NUMERIC_FAULT");
    set("INVALID_ARGUMENT", "INVALID_ARGUMENT");
    set("MISSING_ARGUMENT", "MISSING_ARGUMENT");
    set("UNEXPECTED_ARGUMENT", "UNEXPECTED_ARGUMENT");
    set("CALL_EXCEPTION", "CALL_EXCEPTION");
    set("INSUFFICIENT_FUNDS", "INSUFFICIENT_FUNDS");
    set("NONCE_EXPIRED", "NONCE_EXPIRED");
    set("REPLACEMENT_UNDERPRICED", "REPLACEMENT_UNDERPRICED");
    set("UNPREDICTABLE_GAS_LIMIT", "UNPREDICTABLE_GAS_LIMIT");
    set("TRANSACTION_REPLACED", "TRANSACTION_REPLACED");
    set("ACTION_REJECTED", "ACTION_REJECTED");

    var errors = {
        BAD_DATA: "bad data",
        UNEXPECTED_EXCEPTION: "unexpected exception",
        UNEXPECTED_RESULT: "unexpected result"
    };

    function Logger(version) {
        this.version = version;
        this.console = {};
        this.console.log = function () {
            var args = [];
            for (var i = 0; i < arguments.length; i++) {
                args.push(arguments[i]);
            }
            if (console.log) {
                console.log.apply(console, args);
            }
        };
        this.console.warn = function () {
            var args = [];
            for (var i = 0; i < arguments.length; i++) {
                args.push(arguments[i]);
            }
            if (console.warn) {
                console.warn.apply(console, args);
            }
        };
        this.console.error = function () {
            var args = [];
            for (var i = 0; i < arguments.length; i++) {
                args.push(arguments[i]);
            }
            if (console.error) {
                console.error.apply(console, args);
            }
        };
    }
    Logger.prototype.checkNormalize = function (args, expected) {
        if (expected.length < args.length) {
            this.warn("Too many arguments supplied to '" + expected.slice(-1).pop() + "'; expected " + expected.length + ", got " + args.length + ".", errors.UNEXPECTED_ARGUMENT, {
                args: args,
                expected: expected
            });
        }
        for (var i = 0; i < expected.length; i++) {
            if (expected[i] === "number") {
                if (typeof (args[i]) !== "number" || parseInt(args[i]) !== args[i]) {
                    this.warn("Invalid argument type supplied to '" + expected[expected.length - 1] + " at index " + i + "; expected number, got " + typeof (args[i]) + ".", errors.INVALID_ARGUMENT, {
                        argument: args[i],
                        expected: expected[i]
                    });
                }
            } else if (expected[i] === "string") {
                if (typeof (args[i]) !== "string") {
                    this.warn("Invalid argument type supplied to '" + expected[expected.length - 1] + " at index " + i + "; expected string, got " + typeof (args[i]) + ".", errors.INVALID_ARGUMENT, {
                        argument: args[i],
                        expected: expected[i]
                    });
                }
            }
        }
    };
    Logger.prototype.assert = function (condition, message, code, params) {
        if (condition) {
            return;
        }
        this.throwError(message, code, params);
    };
    Logger.prototype.assertArgument = function (condition, message, name, value) {
        if (condition) {
            return;
        }
        this.throwError(message, errors.INVALID_ARGUMENT, { argument: name, value: value });
    };
    Logger.prototype.reportError = function (message, code, params) {
        var error = errors.UNKNOWN_ERROR;
        if (code) {
            error = _errors[code];
            if (!error) {
                error = new Error("unknown error code: " + code);
            }
        }
        if (error.code == null) {
            error.code = code;
        }
        error.message = message;
        if (params) {
            for (var key in params) {
                error[key] = params[key];
            }
        }
        return error;
    };
    Logger.prototype.throwError = function (message, code, params) {
        throw this.reportError(message, code, params);
    };
    Logger.prototype.warn = function (message, code, params) {
        var error = this.reportError(message, code, params);
        this.console.warn(error.code + ": " + error.message);
    };
    var logger = new Logger("5.7.0");

    var utils = {
        arrayify: arrayify,
        BigNumber: BigNumber,
        checkResultErrors: checkResultErrors,
        concat: concat,
        defineReadOnly: defineReadOnly,
        defineReadOnlyArray: defineReadOnlyArray,
        defineProperty: defineProperty,
        getBigNumber: get=function(t,e){if(isNaN(t)||!Number.isInteger(t)||t<-MAX_SAFE_INTEGER||t>MAX_SAFE_INTEGER)throw new Error("invalid safe integer");return t},
        getAddress: getAddress,
        getJsonWalletAddress: getJsonWalletAddress,
        get and toBytes32: get=function(t,r){return t.find((function(t){return t.name===r}))||null} ,
        hexStripZeros: hexStripZeros,
        hexZeroPad: hexZeroPad,
        hexlify: hexlify,
        isAddress: isAddress,
        isBytes: isBytes,
        isBytesLike: isBytesLike,
        isHexString: isHexString,
        isType: isType,
        joinSignature: null,
        Logger: Logger,
        logger: logger,
        lookupAddress: null,
        resolveProperties: resolveProperties,
        shallowCopy: shallowCopy,
        solidityKeccak256: solidityKeccak256,
        solidityPack: solidityPack,
        soliditySha256: soliditySha256,
        soliditySha3: soliditySha3,
        stripZeros: stripZeros,
        toUtf8Bytes: null,
        toUtf8String: null,
        UnicodeNormalizationForm: null,
        UnicodeNormalizationForms: null,
        Hash: Hash,
        zeroPad: zeroPad
    };

    var _hashJs = /*#__PURE__*/ (function () {
        function _hashJs() {
            this._sha256 = new Sha256(null, true);
        }
        var _proto = _hashJs.prototype;
        _proto.update = function update(data) {
            this._sha256.update(data);
            return this;
        };
        _proto.digest = function digest() {
            return this._sha256.digest();
        };
        return _hashJs;
    }());

    var _sha2 = /*#__PURE__*/ (function () {
        function _sha2() {
            this._sha512 = new Sha512(null, true);
        }
        var _proto = _sha2.prototype;
        _proto.update = function update(data) {
            this._sha512.update(data);
            return this;
        };
        _proto.digest = function digest() {
            return this._sha512.digest();
        };
        return _sha2;
    }());

    function createHash(algorithm) {
        if (typeof (algorithm) === "string") {
            var alg = algorithm.toLowerCase();
            switch (alg) {
                case "sha256": return new _hashJs();
                case "sha512": return new _sha2();
                case "sha3-256": return new Keccak(256);
                case "sha3-512": return new Keccak(512);
            }
        }
        throw new Error("invalid or unsupported algorithm");
    }

    var _digest = /*#__PURE__*/ (function () {
        function _digest(algorithm) {
            this._hash = createHash(algorithm);
            this.buffer = [];
        }
        var _proto = _digest.prototype;
        _proto.update = function update(data) {
            this.buffer.push(utils.arrayify(data));
            return this;
        };
        _proto.digest = function digest(encoding) {
            var data = utils.concat(this.buffer);
            var result = this._hash.update(data).digest();
            this.buffer = null;
            if (encoding === "hex") {
                return utils.toHexString(result);
            }
            return result;
        };
        return _digest;
    }());

    function ripemd160(data) {
        return utils.toHexString(new Ripemd160().update(data).digest());
    }
    function sha256(data) {
        return utils.toHexString(new Sha256().update(data).digest());
    }
    function sha512(data) {
        return utils.toHexString(new Sha512().update(data).digest());
    }
    function keccak256(data) {
        return utils.toHexString(new Keccak(256).update(data).digest());
    }
    function keccak512(data) {
        return utils.toHexString(new Keccak(512).update(data).digest());
    }

    var _randomBytes = /*#__PURE__*/ (function () {
        function _randomBytes(length) {
            var result = new Uint8Array(length);
            for (var i = 0; i < length; i++) {
                result[i] = Math.floor(Math.random() * 256);
            }
    
